\input{../../preamble}
% BUG REPORT TEMPLATE -----------------------------------
%% \noindent\begin{tabularx}{\textwidth}{rY}
%%   \toprule
%%   File & \\
%%   Line & \\
%%   Bug Type & \\
%%   Description & \\
%%   Number of Configurations & \\
%%   \midrule
%%   \multicolumn{2}{c}{Code Sample} \\
%% \end{tabularx}
%% \noindent\lstinputlisting[linerange=, firstnumber=]{code/}
%% \noindent\begin{tabularx}{\textwidth}{rY}
%%   \midrule
%%   Status & \\
%%   Remarks & \\
%%   \bottomrule
%% \end{tabularx}
% -------------------------------------------------------

\title{Toybox Bug Analysis -- infer}
\author{Austin Mordahl}
\begin{document}
\maketitle

\section{Introduction}
\noindent These bugs were generated by Infer v0.15.0 and Toybox 0.7.5. Bug reports are classified into the following categories:

\input{../../bug_classifications}

\pagebreak

\section{Statistics}

\begin{center}
  \noindent\begin{tabular}{rl}\toprule
             True Reports & 7 \\
             Technically True Reports & 5 \\
             False Reports & 68 \\ \bottomrule
           \end{tabular}
\end{center}

\section{Remarks}

This analysis does not include bug reports having the bug type ``Dead Store.'' This type describes bugs in which a value is assigned to a variable but is never used.
In the unique bug reports list, many bugs listed as unique are actually the same (for example, a variable infer recognizes as uninitialized will generate a unique bug report for every occurrence). For convenience, only one instance of each of these bugs is recorded here. [This is an issue I plan to resolve with updated versions of the scripts generating the unique bug reports].
\pagebreak

\section{True Reports}

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & uptime.c\\
  Line & 54\\
  Bug Type & \texttt{NULL\_DEREFERENCE} \\
  Description & pointer \texttt{tm} last assigned on line 53 could be null and is dereferenced at line 54, column 34\\
  Number of Configurations & 495\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=53-54, firstnumber=53]{code/uptime.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & True\\
  Remarks & \texttt{localtime} may fail and return a null pointer, causing tm to be null.\\
  Features & CONFIG_UPTIME \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & lib.c\\
  Line & 1268\\
  Bug Class & \texttt{MEMORY\_LEAK} \\
  Description & \texttt{gr} is not reachable after line 1268, column 3.\\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=1264-1273, firstnumber=1264]{code/lib.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & True\\
  Remarks & The call to \texttt{bufgetgrgid} initializes overwrites the \texttt{list} pointer with pointer to new memory without freeing the memory it pointed to initially. Although the buffer is meant to last past the end of the function, the memory is orphaned each time \texttt{list} is reassigned.\\
  Features & None (generic) \\
  \bottomrule
\end{tabularx}

\pagebreak
\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & lib.c\\
  Line & 1257\\
  Bug Class & \texttt{MEMORY\_LEAK} \\
  Description & \texttt{pw} is not reachable after line 1257, column 3.\\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=1255-1262, firstnumber=1255]{code/lib.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & True\\
  Remarks & The same explanation for \texttt{lib.c:1264} applies here.\\
  Features & None (generic) \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & mkflags.c\\
  Line & 126\\
  Bug Type & \texttt{NULL\_DEREFERENCE}\\
  Description & pointer \texttt{new} last assigned on line 124 could be null and is dereferenced at line 126, column 7.\\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=124-128, firstnumber=124]{code/mkflags.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & True\\
  Remarks & \texttt{calloc} \textit{can} fail, leaving \texttt{new} as a null pointer. Although this is true, it's not particularly interesting, as \texttt{calloc} very rarely fails.\\
  Features & None (generic) \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & mkflags.c\\
  Line & 101\\
  Bug Type & \texttt{NULL\_DEREFERENCE}\\
  Description & pointer \texttt{new} last assigned on line 124 could be null and is dereferenced at line 126, column 7.\\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=124-128, firstnumber=124]{code/mkflags.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & True\\
  Remarks & \texttt{calloc} can fail, leaving \texttt{new} as a null pointer.\\
  Similar Bugs & \texttt{mkflags.c:227} -- pointer \texttt{new} last assigned on line 90 could be null and is dereferenced at line 92, column 7 \\ 
  Features & None (generic) \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & lib.c\\
  Line & 625\\
  Bug Type & \texttt{RESOURCE\_LEAK}\\
  Description & resource acquired by call to \texttt{open()} at line 625, column 31 is not released after line 625, column 17.\\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=611-632, firstnumber=611]{code/lib.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & True\\
  Remarks & If \texttt{O\_CLOEXEC} is passed to \texttt{loopfiles\_rw}, then \texttt{fd} is closed. If \texttt{O\_CLOEXEC} is not passed to \texttt{loopfiles\_rw}, then whatever function is passed to \texttt{loopfiles\_rw} must close \texttt{fd} itself. Of the three calls in toybox to \texttt{loopfiles\_rw} which does not pass \texttt{O\_CLOEXEC}, the call in \texttt{paste.c} does not close \texttt{fd} itself.\\
  Features & None (generic) \\
  \bottomrule
\end{tabularx}

\section{Technically True Reports}

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & nohup.c\\
  Line & 27\\
  Bug Type & \texttt{RESOURCE\_LEAK}\\
  Description & resource acquired by call to \texttt{open()} at line 27, column 15 is not released after line 27, column 9.\\
  Number of Configurations & 476\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=25-36, firstnumber=25]{code/nohup.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & Technically True\\
  Remarks & The file descriptor opened cannot be closed, as the whole point is to redirect \texttt{stdin} and \texttt{stdout} and then run a command elsewhere. This is not a bug, but at the same time infer is not wrong that there is an open file descriptor that is not being closed. Other bugs which involve open resources that are not closed but are meant to stay open are listed below.\\
  Similar Bugs & \texttt{oneit.c:72} -- resource acquired by call to \texttt{xopen\_stdio()} at line 72, column 12 is not released after line 72, column 12. \\
  & \texttt{nohup.c:39} -- resource acquired by call to \texttt{xopen\_stdio()} at line 39, column 5 is not released after line 39, column 5. \\
  Features & CONFIG_NOHUP \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & \texttt{mountpoint.c:53}\\
  Bug Type & Memory Leak\\
  Description & memory dynamically allocated by call to \texttt{xmprintf()} at line 51, column 9 is not reachable after line 53, column 7.\\
  Number of Configurations & 255\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=51-53, firstnumber=51]{code/mountpoint.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & Technically True\\
  Remarks & From the Toybox configuration documentation (\texttt{Config.in}): ``When a program exits, the operating system will clean up after it (free memory, close files, etc). To save size, toybox usually relies on this behavior. If you're running toybox under a debugger or without a real OS (ala newlib+libgloss), enable this to make toybox clean up after itself.'' If \texttt{TOYBOX\_FREE} is not enabled (and by default, it isn't), the memory allocated by \texttt{xmprintf} will not be freed explictly, and instead will be left open until the program terminates so the operating system can clean it up. This makes classifying this bug tricky. This is obviously a memory leak in the default case, as memory that is being allocated is not being freed; however, it seems that this is an intentional choice by the programmers. For now, this seems to fall nicely under the technically true class, but this could warrant a discussion on how exactly we're classifying what a bug is.\\
  Features & CONFIG_MOUNTPOINT, CONFIG_TOYBOX_FREE \\
  \bottomrule
\end{tabularx}

\pagebreak

\section{False Reports}

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & grep.c\\
  Line & 184\\
  Bug Type & \texttt{UNINITIALIZED\_VALUE} \\
  Description & The value read from \texttt{matches.rm\_so} was never initialized.\\
  Number of Configurations & 507\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=178-190, firstnumber=178]{code/grep.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & False\\
  Remarks & Were \texttt{matches.rm\_so} a singular variable, infer would be correct, becuase the initialization of \texttt{matches.rm\_so} would be out of scope. However, \texttt{matches} is a struct which is in scope. Additionally, the else if clause checks whether \texttt{matches.rm\_so} exists; line 184 will not be reached if \texttt{matches.rm\_so} is not initialized.\\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & xwrap.c\\
  Line & 389\\
  Bug Type & \texttt{RESOURCE\_LEAK} \\
  Description & resource acquired by call to \texttt{xopen\_stdio()} at line 389, column 19 is not released after line 389, column 3. \\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=330-342, firstnumber=330]{code/xwrap.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & False \\
  Remarks & \texttt{xopen\_stdio()} automatically closes a file unless the \texttt{O\_CLOEXEC} flag is passed to it (behaves opposite other functions which open files). There are two calls to \texttt{xopen\_stdio()} which do not pass \texttt{O\_CLOEXEC}. The first is in \texttt{oneit.c}, line 99. Here, the file descriptors are kept open on purpose, redirecting \texttt{stdin}, \texttt{stdout}, and \texttt{stderr}. The same pattern is used in the second occurrence. in \texttt{getty.c}.\\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & xwrap.c\\
  Line & 458\\
  Bug Type & \texttt{NULL\_DEREFERENCE}\\
  Description & pointer \texttt{null} could be null and is dereferenced by call to \texttt{getcwd()} at line 458, column 15.\\
  Number of Configurations & 986\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=456-462, firstnumber=456]{code/xwrap.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & False\\
  Remarks & The usage of the \texttt{NULL} pointer should not trigger this error.\\
  \midrule
  \multicolumn{2}{c}{Similar Bugs} \\
  \textit{Condition}:&  Similar bug reports are those in which infer incorrectly identifies a \texttt{NULL} pointer as a Null Dereference bug.\\
  \texttt{pwd.c:26} & pointer \texttt{null} could be null and is dereferenced by call to \texttt{getcwd()} at line 26, column 19. \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & xwrap.c\\
  Line & 213\\
  Bug Type \texttt{UNINITIALIZED\_VALUE}& \\
  Description & The value read from \texttt{cestnepasun[\_]} was never initialized.\\
  Number of Configurations & 986\\
  \midrule
  Status & False\\
  Remarks & \texttt{cestnepasun} is initialized by a call to \texttt{pipe}. This is representative of a broader class of bugs falling into the \texttt{UNINTIALIZED\_VALUE} type. These bugs take the form of two separate branches with the same condition, wherein a variable is intialized in the first and used in the second (i.e. \texttt{int a; if (b) a = 5; ...; if (b) int c = a;} Other false bugs which fall into this class (and similar bugs, i.e. wherein infer doesn't understand the variable being initialized in a different scope) are listed below.\\
  Similar Bugs & \texttt{xwrap.c:287} -- The value read from \texttt{pipe} was never initialized. \\
  & \texttt{mount.c:314} -- The value read from \texttt{mtl} was never initialized. \\
  & \texttt{xwrap.c:790} -- The value read from \texttt{d} was never intialized. \\
  & \texttt{xwrap.c:736} -- The value read from \texttt{fd} was never initialized. \\
  & \texttt{comm.c:62} -- The value read from \texttt{file[\_]} was never initialized.\\
  & \texttt{bzcat.c:251} -- The value read from \texttt{length[\_]} was never initialized. \\
  & \texttt{modinfo.c:72} -- The value readf from \texttt{len} was never initialized.\\
  & \texttt{md5sum.c:203} -- The value read from \texttt{rot[\_]} was never initialized.\\
  & \texttt{ps.c:1456} -- The value read from \texttt{lines} was never initialized. \\
  & \texttt{setenforce.c:30} -- The value read from \texttt{state} was never initialized. \\
  & \texttt{od.c:92} -- The value read from \texttt{ld} was never initialized. \\
  & \texttt{xwrap.c:794} -- The value read from \texttt{l} was never initialized. \\
  & \texttt{hwclock.c:115} -- The value read from \texttt{time} was never initialized. \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & ulimit.c\\
  Line & 95\\
  Bug Type & \texttt{UNINITIALIZED\_VALUE} \\
  Description & The value read from \texttt{rr.rlim\_cur} was never initialized.\\
  Number of Configurations & 510\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=84-99, firstnumber=84]{code/ulimit.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & False\\ 
  Remarks & \texttt{rr} is initialized by a call to \texttt{prlimit}. This bug is representative of a broader class of bugs falling into the \texttt{UNINITIALIZED\_VALUE} type. These bugs take the form of a struct being initialized and then a field in that struct being referenced later. Other false bugs which fall into this class are listed below.\\
  Similar Bugs & \texttt{od.c:88} -- The value read from \texttt{fdl.ld} was never initialized. \\
  & \texttt{od.c:85} -- The value read from \texttt{fdl.d} was never initialized. \\
  & \texttt{ulimit.c:95} -- The value read from \texttt{rr.rlim\_max} was never initialized. \\
  & \texttt{od.c:82} -- The value read from \texttt{fdl.f} was never initialized. \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & ls.c\\
  Line & 424\\
  Bug Type & \texttt{UNINITIALIZED\_VALUE}\\
  Description & The value read from \texttt{totals[\_]} was never initialized.\\
  Number of Configurations & 655\\
  \midrule
  Status & False\\
  Remarks & \texttt{totals} was initialized by memset. Other bugs in which the variable was initialized by memset, memcpy, or any other function which accepts out parameters are listed below.\\
  Similar Bugs & \texttt{md5sum.c:157} -- The value read from \texttt{x[\_]} was never initialized. \\
  Similar Bugs & \texttt{ps.c:1453} -- The value read from \texttt{run[\_]} was never initialized. \\
  & \texttt{md5sum.c:143} -- The value read from \texttt{x[\_]} was never initialized. \\
  & \texttt{ftpget.c:150} -- The value read from \texttt{port} was never initialized. \\
  & \texttt{ftpget.c:151} -- The value read from \texttt{si6.sin6\_family} was never initialized. \\
  & \texttt{rfkill.c:82} -- The value reaf from \texttt{rfevent.idx} was never initialized. \\
  & \texttt{ls.c:349} -- The value read from \texttt{dtlen} was never initialized. \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & pmap.c\\
  Line & 86\\
  Bug Type & \texttt{UNINITIALIZED\_VALUE}\\
  Description & The value read from swap was never intialized.\\
  Number of Configurations & 500\\
  \midrule
  \multicolumn{2}{c}{Code Sample} \\
\end{tabularx}
\noindent\lstinputlisting[linerange=78-86, firstnumber=78]{code/pmap.c}
\noindent\begin{tabularx}{\textwidth}{rY}
  \midrule
  Status & False\\
  Remarks & \texttt{swap} is initialized in the loop above.\\
  Similar Bugs & \texttt{pmap.c:86} -- The value read from \texttt{dirty} was never initialized. \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & sed.c\\
  Line & 671\\
  Bug Type & \texttt{MEMORY\_LEAK}\\
  Description & Memory dynamically allocated to \texttt{return} by call to \texttt{xmalloc()} at line 668, column 16 is not reachable after line 671, column 17.\\
  Number of Configurations & 494\\
  \midrule
  Status & False\\
  Remarks & There is no \texttt{return} variable. (This is the same bug as \texttt{sed.c:694}\\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & xwrap.c\\
  Line & 383\\
  Bug Type & \texttt{RESOURCE\_LEAK}\\
  Description & resource acquired by call to \texttt{xcreate\_stdio()} at line 383, column 19 is not released after line 383, column 3.\\
  Number of Configurations & 986\\
  \midrule
  Status & False\\
  Remarks & No calls to \texttt{xcreate} pass \texttt{O\_CLOEXEC}, so the file will always be closed automatically.\\
  \midrule
  \multicolumn{2}{c}{Similar Bugs} \\
  \textit{Condition} & \texttt{xopen} and \texttt{xcreate} close files by default unless \texttt{O\_CLOEXEC} is passed to them. These bugs involve instances in which the file opened by those functions is not closed explicitly, but \texttt{O\_CLOEXEC} is not passed; therefore, we can safely assume that the file is closed. \\
    \texttt{xwrap.c:373} & resource acquired by call to \texttt{xopen\_stdio()} at line 373, column 5 is not released after line 373, column 5. \\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & \texttt{password.c:127}\\
  Bug Type & Null Dereference\\
  Description & pointer \texttt{sfx} last assigned on line 119 could be null and is dereferenced at line 127, column 3.\\
  Number of Configurations & 986\\
  \midrule
  Status & False\\
  Remarks & The string \texttt{strchr} searches is guaranteed to have a '+' in it by \texttt{xmprintf}, so \texttt{strchr} will never fail and \texttt{sfx} will never be null.\\
  \bottomrule
\end{tabularx}

\pagebreak

\noindent\begin{tabularx}{\textwidth}{rY}
  \toprule
  File & \texttt{lsm.h:63}\\
  Bug Type & Uninitialized Value\\
  Description & The value read from \texttt{result} was never initialized.\\
  Number of Configurations & 922\\
  \midrule
  Status & False\\
  Remarks & See the report from cppcheck for the same bug.\\
  \bottomrule
\end{tabularx}

\end{document}
